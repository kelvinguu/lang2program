import os
from gtd.io import makedirs, rsync


class Directory(object):
    """Directory object. Makes the directory if it doesn't exist.

    Args:
        absolute_path (unicode string): absolute path of where directory lives
        sync (bool): whether or not to sync this directory with central
            data dir
    """

    def __init__(self, absolute_path, sync=True):
        self._name = os.path.basename(os.path.normpath(absolute_path))
        self._absolute_path = absolute_path
        self._sync = sync
        makedirs(absolute_path)
        self._subdirs = []

    @property
    def name(self):
        return self._name

    @property
    def sync(self):
        return self._sync

    @property
    def absolute_path(self):
        return self._absolute_path

    @property
    def subdirectories(self):
        return self._subdirs

    def add_dir(self, name, sync=True):
        """Adds a subdirectory named name and returns it."""
        new_dir = Directory(self._absolute_path + '/' + name, sync)
        self._subdirs.append(new_dir)
        return new_dir


class DataDirectory:
    """Specifies the structure of the data directory from pull-dependencies script.

    Must first set the environmental variable STRONGSUP_DIR to the
    absolute path of the directory containing data before using this class.
    """
    # Set location of local data directory from environment variable
    env_var = 'STRONGSUP_DIR'
    if env_var not in os.environ:
        assert False, env_var + ' environmental variable must be set.'
    root = os.environ[env_var]

    # Base directory helper
    _base_dir = Directory(root)

    # Directory containing artificial tables generated by ArtificialStepDataset
    _artificial_tables_dir = _base_dir.add_dir(
            'artificial_tables', sync=True)
    artificial_tables = _artificial_tables_dir.absolute_path

    # Columns for artificial tables
    columns = _artificial_tables_dir.add_dir(
            'columns', sync=True).absolute_path

    # Directory containing GloVe vectors
    glove = _base_dir.add_dir('glove.6B', sync=True).absolute_path

    # Directory containing experiment results
    experiments = _base_dir.add_dir('experiments', sync=False).absolute_path

    # Directory containing WikiTablesQuestions data
    wiki_table_questions = _base_dir.add_dir(
            'WikiTableQuestions', sync=True).absolute_path

    # Directory containing raw steps data
    raw_steps_data = _base_dir.add_dir(
            'raw_steps_data', sync=True).absolute_path

    # Directory containing processed steps data
    steps = _base_dir.add_dir(
            'Steps', sync=True).absolute_path

    # Directory containing SequentialQuestions data
    seq_questions = _base_dir.add_dir(
            'SequentialQA', sync=True).absolute_path

    # Directory containing FileSequences for datasets
    dataset_backup = _base_dir.add_dir(
            'dataset_backup', sync=True).absolute_path

    # Directory containing RLong data
    rlong = _base_dir.add_dir(
            'rlong', sync=True).absolute_path

    # Directory for nlpsub output
    nlpsub = _base_dir.add_dir(
            'nlpsub', sync=False).absolute_path

    # Directory for syncing codalab
    codalab = _base_dir.add_dir(
            'codalab', sync=False).absolute_path

    # Directory for results tables
    results = _base_dir.add_dir(
            'results', sync=True).absolute_path

    @classmethod
    def relative_path(cls, path):
        """Returns the relative path from the data root dir of an absolute
        path"""
        base = cls.root
        if path.find(base) != 0:
            raise ValueError(("{} is not a subdirectory of {} or is not an "
                              "absolute path").format(path, base))
        return os.path.relpath(path, base)
